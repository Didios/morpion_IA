def morpion_IA():
    plateau = [
    ["_", "_", "_"],
    ["_", "_", "_"],
    ["_", "_", "_"]]

    """
    prevoir si le fichier a été supprimé
    contenu de base:
        000000000:None
        None:0
    """
    # on transforme le fichier en dictionnaire
    lecture = read.lire_fichier("cerveau.txt")
    dico = {}
    for ligne in lecture:
        ligne = ligne.split(":")
        dico[ligne[0]] = ligne[1].split(",")

    def creation_arbre(dico, racine):
        ABR = arbre(racine)
        if len(dico[racine]) > 1:
            for fils in dico[racine]:
                ABR.add_fils(creation_arbre(dico, fils))
        else:
            try:
                ABR.add_fils(arbre(int(dico[racine][0])))
            except:
                ABR.add_fils(arbre("None", arbre(0)))
        return ABR

    brain = creation_arbre(dico, "000000000") # cerveau en entier

    reflexion = brain # zone de réfléxion
################################################################################
    xtreme = [len(plateau[0]), len(plateau)]

    fin = [False, "J1"]
    while not fin[0]:
        montrer_plateau(plateau)

        if fin[1] == "J1":
            placer = False
            while not placer:
                lieu = input("A quelle place veut-tu jouer %s ? (de 1.1 à 3.3)" % fin[1])
                if "." in lieu:
                    lieu = lieu.split(".")
                    x = int(lieu[0]) -1
                    y = int(lieu[1]) -1
                    if x > -1 and x < xtreme[0] and y > -1 and y < xtreme[1]:
                        if plateau[x][y] == "_":
                            placer = True
        else:
            situation = convertion_plateau(plateau)
            if situation not in [x.get_racine() for x in reflexion.get_fils()]:
                reflexion.add_fils(arbre(situation, arbre("None", arbre(0))))

            for r in reflexion.get_fils():
                if r.get_racine() == situation:
                    reflexion = r
                    break

            """
            MAJ de l'arbre:
                analyse situation
                si nouvelle situation:
                    ajouter situation à l'arbre
                    ajouter un fils à l'arbre avec comme nom None et valeur 0
                sinon:
                    aller à la branche
            """

            """
            je crois que l'IA est conne en fait:
                pbm de True, False
                pbm de minimax
                int() lors de construction de l'arbre
            """

            choix = minimax(reflexion, False) # mettre True si l'IA joue en 1er

            if choix.get_racine() == "None":
                from random import randint # si on ne sait pas quoi jouer, on joue au hasard

                placement = False
                nbr = 0
                while not placement:
                    nbr += 1
                    x = randint(0, 2)
                    y = randint(0, 2)
                    situation = convertion_plateau(plateau)
                    situation = convertion_chaine(situation)
                    if plateau[x][y] == "_":
                        situation[x][y] = "O"
                    situation = convertion_plateau(situation)

                    if plateau[x][y] == "_" and (situation not in [x.get_racine() for x in reflexion.get_fils()] or nbr > 100): # on place une limite de 100 si seulement des parties perdantes on été faites par la suite
                            placement = True

                if situation not in [x.get_racine() for x in reflexion.get_fils()]:
                    reflexion.add_fils(arbre(situation, arbre("None", arbre(0))))

                for r in reflexion.get_fils():
                    if r.get_racine() == situation:
                        reflexion = r
                        break
            else:
                for r in reflexion.get_fils():
                    if r.get_racine() == choix.get_racine():
                        reflexion = r
                        break

                c = reflexion.get_racine()
                y = 0
                while y < xtreme[1] and c[y] == plateau[y]:
                    y += 1
                x = 0
                while x < xtreme[0] and c[y][x] == plateau[y][x]:
                    x += 1

            """
            choix placement:
                faire minmax pour connaitre la branche à prendre
                si nom de la branche == None:
                    x, y = -1, -1
                    tant que la position x y n'est pas possible et qu'elle n'est pas un fils:
                        choisir x y au pif
                    ajouter la nouvelle situation à l'arbre
                    aller à la branche
                sinon:
                    aller à la branche
                    prendre la racine de la branche
                    comparer la racine à l'analyse
                    donner le placement x y
            """

################################################################################

        if fin[1] == "J1":
            plateau[x][y] = "X"
        elif fin[1] == "IA":
            plateau[x][y] = "O"

        # toutes les possibilité d'arrêt
        ligne = False
        i = 0
        while i < 3 and not ligne:
            if (y+i-2 > -1 and y+i-2 < xtreme[1]) and (y+i > -1 and y+i < xtreme[1]):
                ligne = plateau[x][y + i -2] == plateau[x][y + i -1] == plateau[x][y + i] # colonnes

            if (x+i-2 > -1 and x+i-2 < xtreme[0]) and (x+i > -1 and x+i < xtreme[0]) and not ligne:
                ligne = plateau[x + i -2][y] == plateau[x + i -1][y] == plateau[x + i][y] # lignes

            if (y+i-2 > -1 and y+i-2 < xtreme[1]) and (y+i > -1 and y+i < xtreme[1]) and (x+i-2 > -1 and x+i-2 < xtreme[0]) and (x+i > -1 and x+i < xtreme[0]) and not ligne:
                ligne = plateau[x + i -2][y + i -2] == plateau[x + i -1][y + i -1] == plateau[x + i][y + i] # diagonale \

            if (y-i+2 > -1 and y-i+2 < xtreme[1]) and (y-i > -1 and y-i < xtreme[1]) and (x+i-2 > -1 and x+i-2 < xtreme[0]) and (x+i > -1 and x+i < xtreme[0]) and not ligne:
                ligne = plateau[x + i -2][y - i +2] == plateau[x + i -1][y - i +1] == plateau[x + i][y - i] # diagonale /
            i += 1

        plein = "_" not in plateau[0] + plateau[1] + plateau[2]

        if ligne:
            fin[0] = True
        elif plein:
            fin[0] = True
            fin[1] = "0"
        elif fin[1] == "J1":
            fin[1] = "IA"
        else:
            fin[1] = "J1"

    montrer_plateau(plateau)

    situation = convertion_plateau(plateau)
    scenarios = [x.get_racine() for x in reflexion.get_fils()] # les scenarios déjà connus

    if fin[1] == "J1":
        if situation not in scenarios:
            reflexion.add_fils(arbre(situation, arbre(-1)))
        else:
            for r in reflexion.get_fils():
                if r.get_racine() == situation:
                    reflexion = r
                    break
            fils = reflexion.get_fils()[0].get_racine()
            reflexion.set_fils(arbre(fils-1))
    elif fin[1] == "IA":
        if situation not in scenarios:
            reflexion.add_fils(arbre(situation, arbre(1)))
        else:
            for r in reflexion.get_fils():
                if r.get_racine() == situation:
                    reflexion = r
                    break
            fils = reflexion.get_fils()[0].get_racine()
            reflexion.set_fils(arbre(fils+1))
    elif situation not in scenarios:
        reflexion.add_fils(arbre(situation, arbre(0)))

    # enregistrement du nouvel arbre

    def creation_dico(ABR):
        dico = {}
        l = []
        for fils in ABR.get_fils():
            try:
                if fils.est_feuille():
                    l += [fils.get_racine()]
                else:
                    l += [creation_dico(fils)]
            except:
                l += [fils]
        dico[ABR.get_racine()] = l
        return dico

    dico = creation_dico(brain)

    dico_unique = False
    while not dico_unique:
        nouv_dico = []
        for keys, values in dico.items():
            nouv_val = []
            for i in values:
                if type(i) == dict:
                    nouv_dico += [i]
                    for d in i.keys():
                        nouv_val += [d]
                else:
                    nouv_val += [i]
            dico[keys] = nouv_val

        for d in nouv_dico:
            dico.update(d)

        if nouv_dico == []:
            dico_unique = True

    # transformation du dictionnaire en chaine de caracteres
    contenu = ""
    for keys, values in dico.items():
        contenu += keys
        contenu += ":"
        for indice in values:
            contenu += str(indice) + ","
        contenu = contenu[:-1]
        contenu += "\n"

    read.suppr_fichier("cerveau.txt", False)
    read.add_fichier("", "cerveau.txt", contenu)
    """
    analyse situation
    si IA perdu:
        si situation nouvelle:
            créer situation avec comme fils -1
        sinon:
            aller à situation
            prendre le fils et y enlever 1
    sinon si IA gagné:
        si situation nouvelle:
            creer situation avec comme fils 1
        sinon:
            aller à situation
            prendre le fils et y ajouter 1
    sinon si situation nouvelle:
            creer situation avec comme fils 0
    """

    if fin[1] == "0":
        print("Match nul")
    else:
        print("La joueur %s a gagné !" % fin[1])

def entrainement(fois=1, joueur="J1"):
    score = {}
    score["IA"] = 0
    score["aleatoire"] = 0
    score["nul"] = 0
    for i in range(fois):
        plateau = [
        ["_", "_", "_"],
        ["_", "_", "_"],
        ["_", "_", "_"]]
        # on transforme le fichier en dictionnaire
        lecture = read.lire_fichier("cerveau.txt")
        dico = {}
        for ligne in lecture:
            ligne = ligne.split(":")
            dico[ligne[0]] = ligne[1].split(",")
        def creation_arbre(dico, racine):
            ABR = arbre(racine)
            if len(dico[racine]) > 1:
                for fils in dico[racine]:
                    ABR.add_fils(creation_arbre(dico, fils))
            else:
                try:
                    ABR.add_fils(arbre(int(dico[racine][0])))
                except:
                    ABR.add_fils(arbre("None", arbre(0)))
            return ABR

        brain = creation_arbre(dico, "000000000") # cerveau en entier
        reflexion = brain # zone de réfléxion
        xtreme = [len(plateau[0]), len(plateau)]

        fin = [False, joueur]
        while not fin[0]:
            if fin[1] == "J1":
                placer = False
                from random import randint
                while not placer:
                    x = randint(0,2)
                    y = randint(0,2)
                    if x > -1 and x < xtreme[0] and y > -1 and y < xtreme[1]:
                        if plateau[x][y] == "_":
                            placer = True
            else:
                situation = convertion_plateau(plateau)
                if situation not in [x.get_racine() for x in reflexion.get_fils()]:
                    reflexion.add_fils(arbre(situation, arbre("None", arbre(0))))

                # on enleve les None si toutes les possibilité sont faites
                nbr_pos = compter_pos(situation)
                fils = reflexion.get_fils()
                if nbr_pos +1 < len(fils):
                    f = []
                    for i in fils:
                        if i.get_racine() != "None":
                            f += [i]
                    reflexion.set_fils(*f)

                for r in reflexion.get_fils():
                    if r.get_racine() == situation:
                        reflexion = r
                        break

                choix = minimax(reflexion, False) # mettre True si l'IA joue en 1er
                if choix.get_racine() == "None":
                    from random import randint # si on ne sait pas quoi jouer, on joue au hasard
                    placement = False
                    nbr = 0
                    while not placement:
                        nbr += 1
                        x = randint(0, 2)
                        y = randint(0, 2)
                        situation = convertion_plateau(plateau)
                        situation = convertion_chaine(situation)
                        if plateau[x][y] == "_":
                            situation[x][y] = "O"
                        situation = convertion_plateau(situation)
                        if plateau[x][y] == "_" and (situation not in [x.get_racine() for x in reflexion.get_fils()] or nbr > 100): # on place une limite de 100 si seulement des parties perdantes on été faites par la suite
                            placement = True

                    if situation not in [x.get_racine() for x in reflexion.get_fils()]:
                        reflexion.add_fils(arbre(situation, arbre("None", arbre(0))))

                    for r in reflexion.get_fils():
                        if r.get_racine() == situation:
                            reflexion = r
                            break
                else:
                    for r in reflexion.get_fils():
                        if r.get_racine() == choix.get_racine():
                            reflexion = r
                            break
                    c = reflexion.get_racine()
                    y = 0
                    while y < xtreme[1] and c[y] == plateau[y]:
                        y += 1
                    x = 0
                    while x < xtreme[0] and c[y][x] == plateau[y][x]:
                        x += 1

            if fin[1] == "J1":
                plateau[x][y] = "X"
            elif fin[1] == "IA":
                plateau[x][y] = "O"

            print("%s place :" % fin[1])
            montrer_plateau(plateau)

            # toutes les possibilité d'arrêt
            ligne = False
            i = 0
            while i < 3 and not ligne:
                if (y+i-2 > -1 and y+i-2 < xtreme[1]) and (y+i > -1 and y+i < xtreme[1]):
                    ligne = plateau[x][y + i -2] == plateau[x][y + i -1] == plateau[x][y + i] # colonnes
                if (x+i-2 > -1 and x+i-2 < xtreme[0]) and (x+i > -1 and x+i < xtreme[0]) and not ligne:
                    ligne = plateau[x + i -2][y] == plateau[x + i -1][y] == plateau[x + i][y] # lignes
                if (y+i-2 > -1 and y+i-2 < xtreme[1]) and (y+i > -1 and y+i < xtreme[1]) and (x+i-2 > -1 and x+i-2 < xtreme[0]) and (x+i > -1 and x+i < xtreme[0]) and not ligne:
                    ligne = plateau[x + i -2][y + i -2] == plateau[x + i -1][y + i -1] == plateau[x + i][y + i] # diagonale \
                if (y-i+2 > -1 and y-i+2 < xtreme[1]) and (y-i > -1 and y-i < xtreme[1]) and (x+i-2 > -1 and x+i-2 < xtreme[0]) and (x+i > -1 and x+i < xtreme[0]) and not ligne:
                    ligne = plateau[x + i -2][y - i +2] == plateau[x + i -1][y - i +1] == plateau[x + i][y - i] # diagonale /
                i += 1
            plein = "_" not in plateau[0] + plateau[1] + plateau[2]

            if ligne:
                fin[0] = True
            elif plein:
                fin[0] = True
                fin[1] = "0"
            elif fin[1] == "J1":
                fin[1] = "IA"
            else:
                fin[1] = "J1"

        montrer_plateau(plateau)
        situation = convertion_plateau(plateau)
        scenarios = [x.get_racine() for x in reflexion.get_fils()] # les scenarios déjà connus

        if fin[1] == "J1":
            if situation not in scenarios:
                reflexion.add_fils(arbre(situation, arbre(-1)))
            else:
                for r in reflexion.get_fils():
                    if r.get_racine() == situation:
                        reflexion = r
                        break
                fils = reflexion.get_fils()[0].get_racine()
                reflexion.set_fils(arbre(fils-1))
        elif fin[1] == "IA":
            if situation not in scenarios:
                reflexion.add_fils(arbre(situation, arbre(1)))
            else:
                for r in reflexion.get_fils():
                    if r.get_racine() == situation:
                        reflexion = r
                        break
                fils = reflexion.get_fils()[0].get_racine()
                reflexion.set_fils(arbre(fils+1))
        elif situation not in scenarios:
            reflexion.add_fils(arbre(situation, arbre(0)))

        # enregistrement du nouvel arbre
        def creation_dico(ABR):
            dico = {}
            l = []
            for fils in ABR.get_fils():
                try:
                    if fils.est_feuille():
                        l += [fils.get_racine()]
                    else:
                        l += [creation_dico(fils)]
                except:
                    l += [fils]
            dico[ABR.get_racine()] = l
            return dico

        dico = creation_dico(brain)
        dico_unique = False
        while not dico_unique:
            nouv_dico = []
            for keys, values in dico.items():
                nouv_val = []
                for i in values:
                    if type(i) == dict:
                        nouv_dico += [i]
                        for d in i.keys():
                            nouv_val += [d]
                    else:
                        nouv_val += [i]
                dico[keys] = nouv_val

            for d in nouv_dico:
                dico.update(d)

            if nouv_dico == []:
                dico_unique = True

        # transformation du dictionnaire en chaine de caracteres
        contenu = ""
        for keys, values in dico.items():
            contenu += keys
            contenu += ":"
            for indice in values:
                contenu += str(indice) + ","
            contenu = contenu[:-1]
            contenu += "\n"

        if fin[1] == "0":
            score["nul"] += 1
        elif fin[1] == "IA":
            score["IA"] += 1
        else:
            score["aleatoire"] += 1
        print(score)

        import time
        time.sleep(1)
        read.suppr_fichier("cerveau.txt", False)
        read.add_fichier("", "cerveau.txt", contenu)